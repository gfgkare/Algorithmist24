<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 800px;
            padding: 20px;
        }

        h1 {
            text-align: center;
        }

        h2 {
            margin-top: 20px;
        }

        h3 {
            margin-top: 10px;
        }

        ol {
            list-style-type: decimal;
            margin-left: 20px;
        }

        ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        a {
            color: #007bff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <h1>ALGORITHMIST’24</h1>

    <h2>List of Algorithms</h2>

    <ol>
        <li>
            <strong>Longest common subsequence:</strong> This algorithm finds the longest subsequence that is common to two strings. It is used in many applications, such as text comparison and DNA sequence analysis.
            <ul>
                <li><a href="https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/">GeeksforGeeks</a></li>
                <li><a href="https://www.javatpoint.com/longest-common-subsequence">JavaTpoint</a></li>
                <li><a href="https://www.youtube.com/watch?v=sSno9rV8Rhg">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=NPZn9jBrX8U">YouTube Video 2</a></li>
            </ul>
        </li>
        <li>
            <strong>Edit distance:</strong> Given two strings str1 and str2 of length M and N respectively and below operations that can be performed on str1. Find the minimum number of edits (operations) to convert ‘str1‘ into ‘str2‘. It is used in many applications, such as text comparison and spell checking.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=fJaKO8FbDdo">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=We3YDTzNXEk">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/edit-distance-dp-5/">GeeksforGeeks</a></li>
            </ul>
        </li>
        <li>
            <strong>Longest common prefix:</strong> The longest common prefix for an array of strings is the common prefix between 2 most dissimilar strings. For example, in the given array {“apple”, “ape”, “zebra”}, there is no common prefix because the 2 most dissimilar strings of the array “ape” and “zebra” do not share any starting characters.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=VTr3Nh7BadI">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=wtOQaovlvhY">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/longest-common-prefix-using-sorting/">GeeksforGeeks</a></li>
                <li><a href="https://www.javatpoint.com/longest-common-prefix-in-python">JavaTpoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Sequence Alignment:</strong> Algorithms that align two or more sequences in order to find similarities and differences between them. The Needleman-Wunsch algorithm is a dynamic programming algorithm that finds the global alignment of two sequences.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=of3B02hZGS0&ab_channel=FarhanHaq">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/sequence-alignment-problem/">GeeksforGeeks</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Wikipedia</a></li>
            </ul>
        </li>
        <li>
            <strong>Knapsack Problem:</strong> The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.
            <ul>
                <li><a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/">GeeksforGeeks</a></li>
                <li><a href="https://www.youtube.com/watch?v=8LusJS5-AGo">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=xOlhR_2QCXY">YouTube Video 2</a></li>
            </ul>
        </li>
        <li>
            <strong>Traveling Salesman Problem (TSP):</strong> TSP is a classic algorithmic problem in the fields of computer science and operations research. It is a special case of the traveling purchaser problem and the vehicle routing problem. In the TSP, a salesman is given a list of cities and must determine the shortest route that allows them to visit each city exactly once and return to their starting city.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=xYkz0aDy-oc">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=nNZzVZEiso4">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/traveling-salesman-problem-tsp-implementation/">GeeksforGeeks</a></li>
            </ul>
        </li>
        <li>
            <strong>Breadth-First Search (BFS):</strong> BFS is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root, and explores all the neighbor nodes at the present depth prior to moving to nodes at the next depth level.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=QRq6p9s8NVg">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/data_structures_algorithms/breadth_first_traversal.htm">TutorialsPoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Depth-First Search (DFS):</strong> DFS is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=7fujbpJ0LB4">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/">GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/data_structures_algorithms/depth_first_traversal.htm">TutorialsPoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Dijkstra's Algorithm:</strong> Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=pVfj6mxhdMw">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/data_structures_algorithms/dijkstra_algorithm.htm">TutorialsPoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Bellman-Ford Algorithm:</strong> Bellman-Ford algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=FtN3BYH2Zes">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/">GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/data_structures_algorithms/bellman_ford_algorithm.htm">TutorialsPoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Floyd-Warshall Algorithm:</strong> The Floyd-Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles). A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between all pairs of vertices.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=oNI0rf2P9gE">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/">GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/data_structures_algorithms/floyd_warshall_algorithm.htm">TutorialsPoint</a></li>
            </ul>
        </li>
        <li>
            <strong>A* Algorithm:</strong> A* is a computer algorithm that is widely used in pathfinding and graph traversal. The algorithm efficiently plots a walkable path between multiple nodes, or points, on the graph. A* achieves better performance by using heuristics to guide its search.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=ySN5Wnu88nE">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/a-search-algorithm/">GeeksforGeeks</a></li>
                <li><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia</a></li>
            </ul>
        </li>
        <li>
            <strong>Topological Sorting:</strong> Topological sorting of a directed graph is a linear ordering of its vertices such that for every directed edge u v from vertex u to vertex v, u comes before v in the ordering.
            <ul>
                <li><a href="https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/">GeeksforGeeks</a>
